// ---
// Змінні та типи даних у JavaScript
//
// Змінна — це іменований контейнер для зберігання даних. Вона дозволяє зберігати, змінювати та використовувати значення у програмі.
// Оголошення змінної: let, const або var
//
// let a = 5; // змінна з числовим значенням (тип number)
// const name = "Dima"; // змінна з рядковим значенням (тип string)
// var flag = true; // булевий тип (true/false)
//
// Основні типи даних у JavaScript:
// - Number: числа (5, 3.14)
// - String: рядки ("Hello", 'world')
// - Boolean: логічний тип (true, false)
// - Undefined: змінна оголошена, але не має значення
// - Null: "порожнє" значення
// - Object: складна структура для зберігання даних (масиви, об'єкти)
// - Symbol, BigInt: спеціальні типи (рідко використовуються)
//
// Приклад:
// let age = 30; // Number
// let user = {name: "Anna"}; // Object
// let isActive = false; // Boolean
// let nothing = null; // Null
// let notDefined; // Undefined
//
// typeof дозволяє дізнатися тип даних:
// console.log(typeof age); // "number"
// console.log(typeof user); // "object"
// console.log(typeof isActive); // "boolean"
// ---

// ---
// Оператори, умовні конструкції та цикли у JavaScript
//
// Оператори:
// Арифметичні оператори дозволяють виконувати математичні дії:
// + (додавання), - (віднімання), * (множення), / (ділення), % (остача від ділення), ++ (інкремент), -- (декремент)
// let x = 10 + 5; // 15 (додавання)
// let y = x * 2; // 30 (множення)
// let z = y % 4; // 2 (остача від ділення)
// x++; // x = 16 (збільшення на 1)
//
// Оператори порівняння використовуються для порівняння значень:
// > (більше), < (менше), >= (більше або дорівнює), <= (менше або дорівнює), == (нестроге рівність), === (строге рівність), != (нестроге нерівність), !== (строге нерівність)
// console.log(5 > 3); // true (5 більше за 3)
// console.log(5 == '5'); // true (значення рівні, тип ігнорується)
// console.log(5 === '5'); // false (типи різні: число і рядок)
//
// Логічні оператори дозволяють комбінувати умови:
// && (і) — true, якщо обидві умови істинні
// || (або) — true, якщо хоча б одна умова істинна
// ! (не) — інвертує значення
// console.log(true && false); // false (обидва мають бути true)
// console.log(true || false); // true (достатньо одного true)
// console.log(!true); // false (інверсія)
//
// Умовні конструкції:
// if, else if, else — дозволяють виконувати різний код залежно від умови
// let age = 18;
// if (age >= 18) {
//   console.log('Дорослий'); // Виконається, якщо age >= 18
// } else {
//   console.log('Дитина'); // Виконається, якщо age < 18
// }
//
// switch — зручно для перевірки кількох значень однієї змінної
// switch (age) {
//   case 18:
//     console.log('Вам 18!'); // Виконається, якщо age === 18
//     break;
//   case 21:
//     console.log('Вам 21!'); // Виконається, якщо age === 21
//     break;
//   default:
//     console.log('Інший вік'); // Виконається, якщо жоден case не підходить
// }
//
// Цикли:
// for — використовується для повторення дій певну кількість разів
// for (let i = 0; i < 5; i++) {
//   console.log('i =', i); // Виведе числа від 0 до 4
// }
//
// while — виконує блок коду, поки умова істинна
// let j = 0;
// while (j < 3) {
//   console.log('j =', j); // Виведе 0, 1, 2
//   j++;
// }
//
// do...while — спочатку виконує код, потім перевіряє умову
// let k = 0;
// do {
//   console.log('k =', k); // Виведе 0, 1
//   k++;
// } while (k < 2);
// ---

// ---
// Детальніше про умовні конструкції та цикли у JavaScript
//
// if — перевіряє умову. Якщо вона істинна (true), виконується блок коду після if.
// if (умова) {
//   // цей код виконається, якщо умова true
// }
//
// if...else — якщо умова false, виконається блок після else.
// let age = 16;
// if (age >= 18) {
//   console.log('Дорослий'); // не виконається
// } else {
//   console.log('Дитина'); // виконається, бо age < 18
// }
//
// if...else if...else — можна перевіряти кілька умов послідовно:
// let score = 75;
// if (score >= 90) {
//   console.log('Відмінно');
// } else if (score >= 60) {
//   console.log('Добре'); // виконається, бо 75 >= 60
// } else {
//   console.log('Потрібно підтягнути');
// }
//
// Як працюють цикли:
// for — виконує код певну кількість разів. Складається з 3 частин:
// for (початкове значення; умова; крок) {
//   // код, який повторюється
// }
//
// for (let i = 0; i < 3; i++) {
//   // i = 0: умова true, виконується код, i++ (i=1)
//   // i = 1: умова true, виконується код, i++ (i=2)
//   // i = 2: умова true, виконується код, i++ (i=3)
//   // i = 3: умова false, цикл завершується
//   console.log('i =', i);
// }
//
// while — перевіряє умову перед кожною ітерацією:
// let j = 0;
// while (j < 2) {
//   // j = 0: умова true, виконується код, j++ (j=1)
//   // j = 1: умова true, виконується код, j++ (j=2)
//   // j = 2: умова false, цикл завершується
//   console.log('j =', j);
//   j++;
// }
//
// do...while — спочатку виконує код, потім перевіряє умову:
// let k = 0;
// do {
//   // k = 0: виконується код, k++ (k=1), перевіряється умова
//   // k = 1: виконується код, k++ (k=2), перевіряється умова
//   // k = 2: умова false, цикл завершується
//   console.log('k =', k);
//   k++;
// } while (k < 2);
// ---

// ---
// Додаткові цикли: forEach, for...in, for...of
//
// forEach — це метод масиву, який викликає передану функцію для кожного елемента масиву.
// Він не повертає новий масив, а просто виконує дію для кожного елемента.
// Синтаксис: arr.forEach(function(item, index, array) { ... });
//
// 1. Простий приклад:
// let arr = [10, 20, 30];
// arr.forEach(function(item) {
//   console.log('Елемент:', item);
// });
// // Виведе:
// // Елемент: 10
// // Елемент: 20
// // Елемент: 30
//
// 2. З індексом:
// arr.forEach(function(item, index) {
//   console.log('Елемент:', item, 'Індекс:', index);
// });
// // Виведе:
// // Елемент: 10 Індекс: 0
// // Елемент: 20 Індекс: 1
// // Елемент: 30 Індекс: 2
//
// 3. З доступом до всього масиву:
// arr.forEach(function(item, index, array) {
//   console.log('Елемент:', item, 'Індекс:', index, 'Масив:', array);
// });
//
// 4. Стрілочна функція:
// arr.forEach((item, index) => {
//   console.log(`Елемент №${index + 1}: ${item}`);
// });
//
// 5. Приклад: вивести квадрат кожного числа
// let numbers = [2, 4, 6];
// numbers.forEach(function(num) {
//   console.log(num * num);
// });
// // Виведе: 4, 16, 36
// ---

// ---
// ФУНКЦІЇ У JAVАСRIPТ — ДЕТАЛЬНИЙ РОЗБІР
//
// 1. Оголошення функцій
//
// Function Declaration (Оголошення функції)
// function sayHello(name) {
//   return 'Привіт, ' + name + '!';
// }
// console.log(sayHello('Світ'));
// // Можна викликати до оголошення (hoisting).
// //
// // Function Expression (Функціональний вираз)
// const sum = function(a, b) {
//   return a + b;
// };
// console.log(sum(2, 3));
// // Не піднімається (не можна викликати до оголошення).
// //
// // Arrow Function (Стрілочна функція)
// const multiply = (a, b) => a * b;
// console.log(multiply(2, 4));
// // Коротший синтаксис, не має власного this.
// //
// // 2. Параметри та return
// function greet(name = 'Гість') {
//   return `Вітаю, ${name}!`;
// }
// console.log(greet()); // Вітаю, Гість!
// // Параметри можуть мати значення за замовчуванням.
// // return повертає результат функції.
// //
// // 3. Область видимості (Scope)
// // Змінні, оголошені всередині функції, недоступні зовні.
// function testScope() {
//   let x = 10;
//   console.log(x); // 10
// }
// // console.log(x); // Помилка: x не визначено
// //
// // 4. Замикання (Closures)
// // Функція може "запам'ятовувати" змінні з зовнішньої області видимості.
// function makeCounter() {
//   let count = 0;
//   return function() {
//     count++;
//     return count;
//   };
// }
// const counter = makeCounter();
// console.log(counter()); // 1
// console.log(counter()); // 2
// //
// // 5. Стрілочні функції та this
// // Стрілочна функція не має власного this, вона "успадковує" його ззовні.
// const obj = {
//   value: 42,
//   show: function() {
//     setTimeout(() => {
//       console.log(this.value); // 42
//     }, 100);
//   }
// };
// obj.show();
// //
// // 6. Анонімні та колбек-функції
// // Функції без імені часто використовують як колбеки.
// [1,2,3].forEach(function(num) {
//   console.log(num);
// });
// [1,2,3].forEach(num => console.log(num));
// // ---

// // ---
// // ДЕТАЛЬНО ПРО this У JAVASCRIPT
// //
// // this — це спеціальне ключове слово, яке вказує на "контекст виконання" функції, тобто на об'єкт, у якому функція була викликана.
// //
// // 1. this у глобальному контексті (браузер):
// console.log(this); // window (глобальний об'єкт)
// //
// // 2. this у методі об'єкта:
// const user = {
//   name: 'Іван',
//   showName: function() {
//     console.log(this.name); // this посилається на user
//   }
// };
// user.showName(); // 'Іван'
// //
// // 3. this у звичайній функції (не в об'єкті):
// function show() {
//   console.log(this);
// }
// show(); // у строгому режимі (strict mode) — undefined, інакше window
// //
// // 4. this у конструкторі:
// function Person(name) {
//   this.name = name;
// }
// const p = new Person('Оля');
// console.log(p.name); // 'Оля'
// //
// // 5. Втрата контексту this:
// const obj2 = {
//   value: 100,
//   show: function() {
//     console.log(this.value);
//   }
// };
// const ref = obj2.show;
// ref(); // undefined (this — глобальний об'єкт або undefined)
// //
// // 6. Як зберегти this: call, apply, bind
// function print() {
//   console.log(this);
// }
// const customObj = {a: 1};
// print.call(customObj); // {a: 1}
// print.apply(customObj); // {a: 1}
// const bound = print.bind(customObj);
// bound(); // {a: 1}
// //
// // 7. this у стрілочних функціях:
// // Стрілочна функція не має власного this, вона "успадковує" його ззовні (лексичний контекст)
// const arrowObj = {
//   value: 50,
//   show: () => {
//     console.log(this.value); // undefined, бо this — глобальний об'єкт
//   }
// };
// arrowObj.show();
// //
// const normalObj = {
//   value: 77,
//   show: function() {
//     setTimeout(function() {
//       console.log(this.value); // undefined (this — глобальний об'єкт)
//     }, 100);
//     setTimeout(() => {
//       console.log(this.value); // 77 (стрілочна функція бере this з show)
//     }, 200);
//   }
// };
// normalObj.show();
// //
// // ---
// // Коротко:
// // - this залежить від способу виклику функції
// // - у стрілочних функціях this не створюється, а "успадковується" ззовні
// // - для явного керування this використовують call, apply, bind
// // ---

// // ---
// // КОНСТРУКТОР У JAVАСRIPТ
// //
// // Конструктор — це спеціальна функція, яка використовується для створення нових об'єктів з однаковою структурою.
// // За домовленістю, ім'я конструктора починається з великої літери.
// //
// // Як працює конструктор:
// // 1. Викликається з ключовим словом new: new MyConstructor(...)
// // 2. Створюється новий порожній об'єкт.
// // 3. this всередині конструктора посилається на цей новий об'єкт.
// // 4. Властивості та методи додаються до цього об'єкта через this.
// // 5. Повертається новий об'єкт (якщо явно не повернути інший об'єкт).
// //
// // Приклад конструктора:
// function Car(brand, year) {
//   this.brand = brand;
//   this.year = year;
//   this.drive = function() {
//     console.log(this.brand + ' їде!');
//   };
// }
// const myCar = new Car('Toyota', 2020);
// console.log(myCar.brand); // 'Toyota'
// console.log(myCar.year); // 2020
// myCar.drive(); // 'Toyota їде!'
// //
// // Кожен об'єкт, створений через new Car, матиме свої властивості brand, year і метод drive.
// //
// // Якщо викликати конструктор без new, this буде вказувати на глобальний об'єкт (НЕ робіть так!).
// //
// // Можна додавати методи через прототип:
// Car.prototype.honk = function() {
//   console.log(this.brand + ' сигналить!');
// };
// myCar.honk(); // 'Toyota сигналить!'
// //
// // З 2015 року (ES6) з'явився класовий синтаксис, але під капотом це теж функція-конструктор:
// class Animal {
//   constructor(name) {
//     this.name = name;
//   }
//   speak() {
//     console.log(this.name + ' каже привіт!');
//   }
// }
// const cat = new Animal('Мурчик');
// cat.speak(); // 'Мурчик каже привіт!'
// // ---
// // Коротко:
// // - Конструктор — це функція для створення однотипних об'єктів
// // - Викликається через new
// // - this всередині конструктора — це новий об'єкт
// // - Можна використовувати як старий синтаксис (function), так і новий (class)
// // ---

// // ---
// // ДОДАТКОВО: МЕТА this, call, apply, bind, КОНСТРУКТОРІВ І КЛАСІВ
// //
// // Мета використання this:
// // - this дозволяє функціям і методам працювати з різними об'єктами, не знаючи їх наперед.
// // - Дає змогу писати універсальний код, який можна застосувати до будь-якого об'єкта.
// // - this "підставляється" автоматично залежно від контексту виклику функції.
// //
// // Приклад: універсальний метод для різних об'єктів
// function showName() {
//   console.log(this.name);
// }
// const user1 = {name: 'Оля', show: showName};
// const user2 = {name: 'Петро', show: showName};
// user1.show(); // 'Оля'
// user2.show(); // 'Петро'
// //
// // call, apply, bind — для чого потрібні:
// // - Дозволяють явно вказати, що буде this при виклику функції.
// // - Використовуються, коли потрібно "позичити" метод або виконати функцію в іншому контексті.
// //
// // call: викликає функцію з переданим this і аргументами через кому
// showName.call(user2); // 'Петро'
// //
// // apply: як call, але аргументи передаються масивом
// showName.apply(user1); // 'Оля'
// //
// // bind: створює нову функцію з "прив'язаним" this
// const showPetro = showName.bind(user2);
// showPetro(); // 'Петро'
// //
// // Для чого застосовують конструктори і класи:
// // - Для створення багатьох однотипних об'єктів з однаковою структурою та поведінкою.
// // - Для організації коду, повторного використання логіки, інкапсуляції даних і методів.
// // - Класи — сучасний синтаксис для створення об'єктів і наслідування (OOP).
// //
// // Приклад: створення багатьох користувачів
// function User(name, age) {
//   this.name = name;
//   this.age = age;
// }
// const u1 = new User('Іра', 22);
// const u2 = new User('Макс', 30);
// console.log(u1, u2);
// //
// // Класи дозволяють створювати ієрархії (наслідування):
// class Animal {
//   constructor(name) {
//     this.name = name;
//   }
//   speak() {
//     console.log(this.name + ' каже привіт!');
//   }
// }
// class Dog extends Animal {
//   bark() {
//     console.log(this.name + ' гавкає!');
//   }
// }
// const dog = new Dog('Барсик');
// dog.speak(); // 'Барсик каже привіт!'
// dog.bark(); // 'Барсик гавкає!'
// // ---
// // Коротко:
// // - this — для універсальності функцій/методів
// // - call/apply/bind — для явного керування контекстом
// // - конструктори/класи — для створення багаторазових "шаблонів" об'єктів
// // ---